$date
	Fri Oct  3 17:48:20 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test $end
$var wire 8 ! alu_result_out_bus [7:0] $end
$var reg 1 " clk $end
$scope module Comp $end
$var wire 1 " clk $end
$var wire 8 # const0 [7:0] $end
$var wire 8 $ const1 [7:0] $end
$var wire 4 % status_out_bus [3:0] $end
$var wire 8 & regB_out_bus [7:0] $end
$var wire 8 ' regA_out_bus [7:0] $end
$var wire 8 ( pc_out_bus [7:0] $end
$var wire 7 ) opcode [6:0] $end
$var wire 8 * mux_data_out_bus [7:0] $end
$var wire 8 + muxB_out_bus [7:0] $end
$var wire 8 , muxA_out_bus [7:0] $end
$var wire 8 - k8 [7:0] $end
$var wire 15 . im_out_bus [14:0] $end
$var wire 8 / dm_out_bus [7:0] $end
$var wire 8 0 alu_result_out_bus [7:0] $end
$var wire 4 1 alu_flags_out_bus [3:0] $end
$var wire 3 2 S_alu_sig [2:0] $end
$var wire 1 3 SD_sig $end
$var wire 2 4 SB_sig [1:0] $end
$var wire 2 5 SA_sig [1:0] $end
$var wire 1 6 L_PC_sig $end
$var wire 1 7 LB_sig $end
$var wire 1 8 LA_sig $end
$var wire 1 9 D_W_sig $end
$scope module ALU $end
$var wire 3 : s [2:0] $end
$var wire 4 ; flags_out [3:0] $end
$var wire 8 < b [7:0] $end
$var wire 8 = a [7:0] $end
$var reg 1 > c $end
$var reg 1 ? n $end
$var reg 8 @ result_out [7:0] $end
$var reg 9 A result_with_carry [8:0] $end
$var reg 1 B v $end
$var reg 1 C z $end
$upscope $end
$scope module CU $end
$var wire 1 9 D_W $end
$var wire 1 8 LA $end
$var wire 1 7 LB $end
$var wire 1 6 L_PC $end
$var wire 2 D SA [1:0] $end
$var wire 2 E SB [1:0] $end
$var wire 1 3 SD $end
$var wire 3 F S_alu [2:0] $end
$var wire 7 G opcode [6:0] $end
$var wire 4 H flags_status [3:0] $end
$var reg 1 I d_w_r $end
$var reg 1 J l_pc_r $end
$var reg 1 K la_r $end
$var reg 1 L lb_r $end
$var reg 3 M s_r [2:0] $end
$var reg 2 N sa_r [1:0] $end
$var reg 2 O sb_r [1:0] $end
$var reg 1 P sd_r $end
$upscope $end
$scope module DM $end
$var wire 1 " clk $end
$var wire 8 Q data_in [7:0] $end
$var wire 8 R data_out [7:0] $end
$var wire 1 9 w $end
$var wire 8 S address [7:0] $end
$upscope $end
$scope module IM $end
$var wire 15 T out [14:0] $end
$var wire 8 U address [7:0] $end
$upscope $end
$scope module PC $end
$var wire 1 " clk $end
$var wire 8 V k8 [7:0] $end
$var wire 1 6 load $end
$var reg 8 W pc [7:0] $end
$upscope $end
$scope module Status $end
$var wire 1 " clk $end
$var wire 4 X flags_in [3:0] $end
$var reg 4 Y flags_out [3:0] $end
$upscope $end
$scope module muxA $end
$var wire 8 Z e2 [7:0] $end
$var wire 8 [ e3 [7:0] $end
$var wire 2 \ sel [1:0] $end
$var wire 8 ] e1 [7:0] $end
$var wire 8 ^ e0 [7:0] $end
$var reg 8 _ out [7:0] $end
$upscope $end
$scope module muxB $end
$var wire 8 ` e1 [7:0] $end
$var wire 8 a e2 [7:0] $end
$var wire 8 b e3 [7:0] $end
$var wire 2 c sel [1:0] $end
$var wire 8 d e0 [7:0] $end
$var reg 8 e out [7:0] $end
$upscope $end
$scope module mux_data $end
$var wire 8 f e0 [7:0] $end
$var wire 1 3 s $end
$var wire 8 g e1 [7:0] $end
$var reg 8 h out [7:0] $end
$upscope $end
$scope module regA $end
$var wire 1 " clk $end
$var wire 8 i data [7:0] $end
$var wire 1 8 load $end
$var reg 8 j out [7:0] $end
$upscope $end
$scope module regB $end
$var wire 1 " clk $end
$var wire 8 k data [7:0] $end
$var wire 1 7 load $end
$var reg 8 l out [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 l
b101010 k
b0 j
b101010 i
b101010 h
b0 g
b101010 f
b101010 e
b0 d
b10 c
b0 b
b101010 a
bx `
b0 _
b0 ^
b0 ]
b11 \
b0 [
b1 Z
b0 Y
b0 X
b0 W
b101010 V
b0 U
b1000101010 T
b101010 S
bx R
b101010 Q
0P
b10 O
b11 N
b11 M
0L
1K
0J
0I
b0 H
b10 G
b11 F
b10 E
b11 D
0C
0B
b0 A
b101010 @
0?
0>
b0 =
b101010 <
b0 ;
b11 :
09
18
07
06
b11 5
b10 4
03
b11 2
b0 1
b101010 0
bx /
b1000101010 .
b101010 -
b0 ,
b101010 +
b101010 *
b10 )
b0 (
b0 '
b0 &
b0 %
b1 $
b0 #
0"
b101010 !
$end
#1
b101010 !
b101010 0
b101010 @
b101010 Q
b101010 i
b101010 k
b101010 ,
b101010 =
b101010 _
b0 +
b0 <
b0 e
b1 *
b1 S
b1 h
19
1I
b11 2
b11 :
b11 F
b11 M
b11 4
b11 E
b11 c
b11 O
b0 5
b0 D
b0 \
b0 N
08
0K
b1 -
b1 V
b1 a
b1 f
b100111 )
b100111 G
b10011100000001 .
b10011100000001 T
b1 (
b1 U
b1 W
b101010 '
b101010 ^
b101010 j
1"
#2
0"
#3
b110101 A
b110101 !
b110101 0
b110101 @
b110101 Q
b110101 i
b110101 k
b1011 +
b1011 <
b1011 e
b1011 *
b1011 S
b1011 h
18
1K
b0 2
b0 :
b0 F
b0 M
b10 4
b10 E
b10 c
b10 O
09
0I
b1011 -
b1011 V
b1011 a
b1011 f
b110 )
b110 G
bx /
bx R
bx `
b11000001011 .
b11000001011 T
b10 (
b10 U
b10 W
1"
#4
0"
#5
b101010 +
b101010 <
b101010 e
b101010 /
b101010 R
b101010 `
b1 *
b1 S
b1 h
b11 2
b11 :
b11 F
b11 M
b11 5
b11 D
b11 \
b11 N
b1 4
b1 E
b1 c
b1 O
18
1K
b1000000 A
b101010 !
b101010 0
b101010 @
b101010 Q
b101010 i
b101010 k
b1 -
b1 V
b1 a
b1 f
b100101 )
b100101 G
b0 ,
b0 =
b0 _
b10010100000001 .
b10010100000001 T
b11 (
b11 U
b11 W
b110101 '
b110101 ^
b110101 j
1"
#6
0"
#7
b10 !
b10 0
b10 @
b10 Q
b10 i
b10 k
b10 +
b10 <
b10 e
bx /
bx R
bx `
b10 *
b10 S
b10 h
16
1J
b11 2
b11 :
b11 F
b11 M
b10 4
b10 E
b10 c
b10 O
b11 5
b11 D
b11 \
b11 N
08
0K
b10 -
b10 V
b10 a
b10 f
b1010011 )
b1010011 G
b101010 '
b101010 ^
b101010 j
b101001100000010 .
b101001100000010 T
b100 (
b100 U
b100 W
1"
#8
0"
#9
b110101 A
b110101 !
b110101 0
b110101 @
b110101 Q
b110101 i
b110101 k
b101010 ,
b101010 =
b101010 _
b1011 +
b1011 <
b1011 e
b1011 *
b1011 S
b1011 h
18
1K
b0 2
b0 :
b0 F
b0 M
b10 4
b10 E
b10 c
b10 O
b0 5
b0 D
b0 \
b0 N
06
0J
b1011 -
b1011 V
b1011 a
b1011 f
b110 )
b110 G
b11000001011 .
b11000001011 T
b10 (
b10 U
b10 W
1"
